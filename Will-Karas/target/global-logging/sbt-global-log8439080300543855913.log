[0m[[0m[0mdebug[0m] [0m[0m> Exec(;Test/compile; collectAnalyses, None, Some(CommandSource(network-1)))[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0m> Exec(Test/compile, None, Some(CommandSource(network-1)))[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Test / compile[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@3c2d4274, check cycles: false, forcegc: true[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"3","parents":[]},"eventTime":1621872566978,"message":"Compiling will-karas","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Users/gmixo/Desktop/Will-Karas/#will-karas/Compile"}}})[0m[0J
[0m[[0m[0minfo[0m] [0m[0mcompiling 1 Scala source to C:\Users\gmixo\Desktop\Will-Karas\target\scala-2.12\classes ...[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"compiling 1 Scala source to C:\\Users\\gmixo\\Desktop\\Will-Karas\\target\\scala-2.12\\classes ..."})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///C:/Users/gmixo/Desktop/Will-Karas/src/main/scala/Kmeans.scala"},"buildTarget":{"uri":"file:/C:/Users/gmixo/Desktop/Will-Karas/#will-karas/Compile"},"diagnostics":[],"reset":true})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"3","parents":[]},"eventTime":1621872570694,"message":"Compiled will-karas","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Users/gmixo/Desktop/Will-Karas/#will-karas/Compile"},"errors":0,"warnings":0,"time":3716}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"4","parents":[]},"eventTime":1621872570836,"message":"Compiling will-karas-test","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Users/gmixo/Desktop/Will-Karas/#will-karas/Test"}}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"4","parents":[]},"eventTime":1621872570858,"message":"Compiled will-karas-test","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Users/gmixo/Desktop/Will-Karas/#will-karas/Test"},"errors":0,"warnings":0,"time":22}})[0m[0J
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 5 s, completed 24 ÎœÎ±ÏŠ 2021 7:09:31 Î¼Î¼[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@354a1239, check cycles: false, forcegc: true[0m[0J
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\gmixo\Desktop\Will-Karas\target\scala-2.12\zinc\inc_compile_2.12.zip,true)[0m[0J
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 24 ÎœÎ±ÏŠ 2021 7:09:31 Î¼Î¼[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/gmixo/Desktop/Will-Karas/src/main/scala/Kmeans.scala","languageId":"scala","version":1,"text":"import org.apache.spark.mllib.clustering.{KMeans, KMeansModel}\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.log4j._\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject kmeans {\n\n  def main(args: Array[String]): Unit = {\n\n    Logger.getLogger(\"org.apache.spark.SparkContext\").setLevel(Level.WARN)\n\n    val sparkConf = new SparkConf()\n      .setMaster(\"local[*]\")\n      .setAppName(\"HighestDominance\")\n\n    val sc = new SparkContext(sparkConf)\n\nval currentDir = System.getProperty(\"user.dir\")\nval data = \"file:///\" + currentDir + \"\\\\data1.txt\"\nval outputDir = \"file:///\" + currentDir + \"\\\\output\"\n\nval parsedData = sc.textFile(data).map(s => Vectors.dense(s.split(',').map(_.toDouble))).cache()\n\n// Cluster the data into two classes using KMeans\nval numClusters = 2\nval numIterations = 20\nval clusters = KMeans.train(parsedData, numClusters, numIterations)\n\n// Evaluate clustering by computing Within Set Sum of Squared Errors\nval WSSSE = clusters.computeCost(parsedData)\nprintln(s\"Within Set Sum of Squared Errors = $WSSSE\")\n\nval predictions= clusters.predict(parsedData)\npredictions.collect()\n\n\n// Save and load model\nclusters.save(sc, outputDir)\n// Export to PMML to a String in PMML format\n//println(s\"PMML Model:\\n ${clusters.toPMML}\")\n\n// Export the model to a local file in PMML format\n//clusters.toPMML(outputDir+\"//kmeans.xml\")\n\n// Export the model to a directory on a distributed file system in PMML format\n//clusters.toPMML(sc, outputDir+\"//kmeans\")\n\n// Export the model to the OutputStream in PMML format\nclusters.toPMML(System.out)\n\nsc.stop() \n}\n}"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/gmixo/Desktop/Will-Karas/src/main/scala/Kmeans.scala"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/gmixo/Desktop/Will-Karas/project/project/metals.sbt","languageId":"scala","version":1,"text":"// DO NOT EDIT! This file is auto-generated.\n// This file enables sbt-bloop to create bloop config files.\n\naddSbtPlugin(\"ch.epfl.scala\" % \"sbt-bloop\" % \"1.4.8-19-4d9f966b\")\n"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/gmixo/Desktop/Will-Karas/project/project/metals.sbt"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/gmixo/Desktop/Will-Karas/src/main/scala/Kmeans.scala","languageId":"scala","version":1,"text":"import org.apache.spark.mllib.clustering.{KMeans, KMeansModel}\nimport org.apache.spark.mllib.linalg.Vectors\nimport org.apache.log4j._\nimport org.apache.spark.{SparkConf, SparkContext}\n\nobject kmeans {\n\n  def main(args: Array[String]): Unit = {\n\n    Logger.getLogger(\"org.apache.spark.SparkContext\").setLevel(Level.WARN)\n\n    val sparkConf = new SparkConf()\n      .setMaster(\"local[*]\")\n      .setAppName(\"HighestDominance\")\n\n    val sc = new SparkContext(sparkConf)\n\nval currentDir = System.getProperty(\"user.dir\")\nval data = \"file:///\" + currentDir + \"\\\\data1.txt\"\nval outputDir = \"file:///\" + currentDir + \"\\\\output\"\n\nval parsedData = sc.textFile(data).map(s => Vectors.dense(s.split(',').map(_.toDouble))).cache()\n\n// Cluster the data into two classes using KMeans\nval numClusters = 2\nval numIterations = 20\nval clusters = KMeans.train(parsedData, numClusters, numIterations)\n\n// Evaluate clustering by computing Within Set Sum of Squared Errors\nval WSSSE = clusters.computeCost(parsedData)\nprintln(s\"Within Set Sum of Squared Errors = $WSSSE\")\n\nval predictions= clusters.predict(parsedData)\npredictions.collect()\n\n\n// Save and load model\nclusters.save(sc, outputDir)\n// Export to PMML to a String in PMML format\n//println(s\"PMML Model:\\n ${clusters.toPMML}\")\n\n// Export the model to a local file in PMML format\n//clusters.toPMML(outputDir+\"//kmeans.xml\")\n\n// Export the model to a directory on a distributed file system in PMML format\n//clusters.toPMML(sc, outputDir+\"//kmeans\")\n\n// Export the model to the OutputStream in PMML format\nclusters.toPMML(System.out)\n\nsc.stop() \n}\n}"}})[0m[0J
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m[0J
